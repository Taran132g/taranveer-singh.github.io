"""Example flows for the order execution simulator.

The scenarios here demonstrate how to compose `SimulationConfig`,
`MarketModel`, and `SimulatedExecutor` for different use cases:
- Quick market + limit order walkthrough
- Metrics collection
- SQLite persistence
- Alert replay from the `alerts` table generated by `grok.py`

Run with:
    python example_simulator.py --mode basic
    python example_simulator.py --mode metrics
    python example_simulator.py --mode persistence --db ./simulator_demo.db
    python example_simulator.py --mode alerts --alerts-db ./penny_basing.db --limit 50
"""

from __future__ import annotations

import argparse
import logging
import random
import sqlite3
import time
from pathlib import Path
from typing import Iterable, List, Tuple

from simulator import MarketModel, SimulationConfig, SimulatedExecutor, SimulatorMetrics

LOGGER = logging.getLogger("example_simulator")
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(name)s: %(message)s")


def _static_price(symbol: str) -> float:
    """Return a deterministic price per symbol for examples."""

    base_prices = {"AAPL": 190.0, "MSFT": 410.0, "NVDA": 120.0, "TSLA": 230.0}
    return base_prices.get(symbol.upper(), 100.0)


def _build_executor(metrics: SimulatorMetrics | None = None, db_path: str | None = None) -> SimulatedExecutor:
    """Create a `SimulatedExecutor` with a representative market model."""

    config = SimulationConfig(
        latency_mean_ms=110,
        latency_std_ms=30,
        slippage_min_bps=0.25,
        slippage_max_bps=3.5,
        limit_fill_base_probability=0.6,
        volume_impact_factor=1.1,
    )
    market = MarketModel(config, rng=random.Random(1234))
    return SimulatedExecutor(
        market_model=market,
        current_price_func=_static_price,
        typical_volume_func=lambda symbol: 25_000 if symbol.upper() in {"AAPL", "MSFT"} else 10_000,
        sleep_func=lambda _seconds: None,  # skip real sleep so examples are fast
        metrics=metrics,
        db_path=db_path,
    )


def run_basic_example() -> None:
    """Submit a market and limit order and print their outcomes."""

    executor = _build_executor()
    market_fill = executor.place_order("AAPL", side="BUY", quantity=50, order_type="MARKET")
    limit_order = executor.place_order("AAPL", side="SELL", quantity=50, order_type="LIMIT", limit_price=191.0)

    LOGGER.info("Market order filled: %s", market_fill)
    LOGGER.info("Initial limit order: %s", limit_order)

    for _ in range(5):
        time.sleep(0.05)
        latest = executor.get_order_status(limit_order.order_id)
        LOGGER.info("Polled limit status: %s", latest)
        if latest.status.name in {"FILLED", "CANCELLED"}:
            break


def run_metrics_example() -> None:
    """Capture latency/slippage metrics while placing a few orders."""

    metrics = SimulatorMetrics()
    executor = _build_executor(metrics=metrics)
    for symbol in ["NVDA", "TSLA", "MSFT", "AAPL"]:
        executor.place_order(symbol, side="BUY", quantity=25, order_type="MARKET")
        executor.place_order(symbol, side="SELL", quantity=25, order_type="LIMIT", limit_price=_static_price(symbol) * 1.01)
    LOGGER.info("Metrics summary: %s", metrics.get_summary())


def run_persistence_example(db_path: str) -> None:
    """Persist orders/fills/metrics into the simulator SQLite tables."""

    metrics = SimulatorMetrics()
    executor = _build_executor(metrics=metrics, db_path=db_path)

    executor.place_order("AAPL", side="BUY", quantity=10, order_type="MARKET")
    executor.place_order("AAPL", side="SELL", quantity=10, order_type="LIMIT", limit_price=192.0)

    # Poll once to give the limit order a chance to fill and trigger persistence
    executor.get_order_status(next(iter(executor._orders.keys())))

    LOGGER.info("Wrote simulator state to %s", db_path)
    LOGGER.info("Metrics summary: %s", metrics.get_summary())


def _fetch_alerts(conn: sqlite3.Connection, *, limit: int | None = None) -> List[Tuple]:
    """Read alerts rows for demonstration; tolerates missing tables."""

    try:
        query = "SELECT id, symbol, side, price FROM alerts ORDER BY id DESC"
        if limit:
            query += f" LIMIT {int(limit)}"
        return list(conn.execute(query))
    except sqlite3.Error as exc:  # table missing or schema mismatch
        LOGGER.warning("Skipping alert replay because alerts table is unavailable: %s", exc)
        return []


def simulate_alerts(alerts_db: str, *, limit: int | None = None) -> None:
    """Replay alerts as simple market/limit intents through the simulator."""

    path = Path(alerts_db)
    if not path.exists():
        raise FileNotFoundError(f"alerts DB not found at {alerts_db}")

    metrics = SimulatorMetrics()
    executor = _build_executor(metrics=metrics)

    with sqlite3.connect(path) as conn:
        alerts = _fetch_alerts(conn, limit=limit)

    if not alerts:
        LOGGER.info("No alerts to replay.")
        return

    LOGGER.info("Replaying %d alerts", len(alerts))
    for alert_id, symbol, side, price in alerts:
        # Treat ask-heavy (SELL) as a short; bid-heavy (BUY) as a long
        normalized_side = (side or "").upper()
        if normalized_side == "BUY":
            executor.place_order(symbol, side="BUY", quantity=50, order_type="MARKET")
            executor.place_order(symbol, side="SELL", quantity=50, order_type="LIMIT", limit_price=price * 1.01)
        else:
            executor.place_order(symbol, side="SELL", quantity=50, order_type="MARKET")
            executor.place_order(symbol, side="BUY", quantity=50, order_type="LIMIT", limit_price=price * 0.99)

    LOGGER.info("Metrics summary after alert replay: %s", metrics.get_summary())


def parse_args() -> argparse.Namespace:
    """Parse CLI arguments for example scenarios."""

    parser = argparse.ArgumentParser(description="Example usage of the simulator.")
    parser.add_argument("--mode", choices=["basic", "metrics", "persistence", "alerts"], default="basic")
    parser.add_argument("--db", help="Path to SQLite DB for persistence demo.")
    parser.add_argument("--alerts-db", help="Path to alerts SQLite DB for replay mode.")
    parser.add_argument("--limit", type=int, help="Max alerts to replay in alerts mode.")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    if args.mode == "basic":
        run_basic_example()
    elif args.mode == "metrics":
        run_metrics_example()
    elif args.mode == "persistence":
        if not args.db:
            raise SystemExit("--db is required for persistence mode")
        run_persistence_example(args.db)
    elif args.mode == "alerts":
        if not args.alerts_db:
            raise SystemExit("--alerts-db is required for alerts mode")
        simulate_alerts(args.alerts_db, limit=args.limit)


if __name__ == "__main__":
    main()
